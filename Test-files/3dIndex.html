<!DOCTYPE html>
<html>
<head>
    <title>WebGL 3D Shapes</title>
    <style>
        canvas { 
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas" width="800" height="600"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_Position;
        attribute vec4 a_Color;
        varying vec4 v_Color;

        uniform mat4 u_ModelViewMatrix;
        uniform mat4 u_ProjectionMatrix;

        void main() {
            gl_Position = u_ProjectionMatrix * u_ModelViewMatrix * a_Position;
            v_Color = a_Color;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec4 v_Color;

        void main() {
            gl_FragColor = v_Color;
        }
    </script>

    <script>
        var canvas = document.getElementById('webgl-canvas');
        var gl = canvas.getContext('webgl');
        if (!gl) {
            console.log('WebGL not supported, falling back on experimental-webgl');
            gl = canvas.getContext('experimental-webgl');
        }
        if (!gl) {
            alert('Your browser does not support WebGL');
        }

        var vertexShaderSource = document.getElementById('vertex-shader').text;
        var fragmentShaderSource = document.getElementById('fragment-shader').text;

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
        }

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('ERROR linking program!', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        var vertices = new Float32Array([
            // Cube vertices
            // Front face
            -0.5,  0.5,  0.5, 1.0, 0.0, 0.0, // Red
            -0.5, -0.5,  0.5, 1.0, 1.0, 0.0, // Yellow
             0.5, -0.5,  0.5, 0.0, 1.0, 0.0, // Green
             0.5,  0.5,  0.5, 0.0, 0.0, 1.0, // Blue
            // Back face
            -0.5,  0.5, -0.5, 1.0, 0.0, 1.0, // Magenta
            -0.5, -0.5, -0.5, 1.0, 1.0, 1.0, // White
             0.5, -0.5, -0.5, 0.0, 1.0, 1.0, // Cyan
             0.5,  0.5, -0.5, 1.0, 0.5, 0.0, // Orange
            // Pyramid vertices
            // Base
            -0.5, -0.5, -0.5, 1.0, 0.0, 0.0, // Red
             0.5, -0.5, -0.5, 1.0, 1.0, 0.0, // Yellow
             0.5, -0.5,  0.5, 0.0, 1.0, 0.0, // Green
            -0.5, -0.5,  0.5, 0.0, 0.0, 1.0, // Blue
            // Top
             0.0,  0.5,  0.0, 1.0, 0.0, 1.0  // Magenta
        ]);

        var indices = new Uint8Array([
            // Cube indices
            0, 1, 2, 0, 2, 3, // Front face
            4, 5, 6, 4, 6, 7, // Back face
            0, 4, 7, 0, 7, 3, // Left face
            1, 5, 6, 1, 6, 2, // Right face
            3, 2, 6, 3, 6, 7, // Top face
            0, 1, 5, 0, 5, 4, // Bottom face
            // Pyramid indices
            8, 9, 10, // Base
            8, 10, 11, // Base
            8, 9, 12, // Side
            9, 10, 12, // Side
            10, 11, 12, // Side
            11, 8, 12 // Side
        ]);

        var vertexBuffer = gl.createBuffer();
        if (!vertexBuffer) {
            console.error('Failed to create the buffer object');
            return -1;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        var indexBuffer = gl.createBuffer();
        if (!indexBuffer) {
            console.error('Failed to create the buffer object');
            return -1;
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        var FSIZE = vertices.BYTES_PER_ELEMENT;

        var a_Position = gl.getAttribLocation(program, 'a_Position');
        gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0);
        gl.enableVertexAttribArray(a_Position);

        var a_Color = gl.getAttribLocation(program, 'a_Color');
        gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3);
        gl.enableVertexAttribArray(a_Color);

        var u_ModelViewMatrix = gl.getUniformLocation(program, 'u_ModelViewMatrix');
        var u_ProjectionMatrix = gl.getUniformLocation(program, 'u_ProjectionMatrix');

        var modelViewMatrix = new Matrix4();
        var projectionMatrix = new Matrix4();
        var aspect = canvas.width / canvas.height;
        projectionMatrix.setPerspective(45, aspect, 1, 100);

        // Initial camera position
        var eyeX = 0.0, eyeY = 0.0, eyeZ = 5.0;
        var upX = 0.0, upY = 1.0, upZ = 0.0;
        var centerX = 0.0, centerY = 0.0, centerZ = 0.0;
        modelViewMatrix.setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);

        gl.uniformMatrix4fv(u_ModelViewMatrix, false, modelViewMatrix.elements);
        gl.uniformMatrix4fv(u_ProjectionMatrix, false, projectionMatrix.elements);

        gl.clearColor(0.9, 0.9, 0.9, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Draw 9 shapes in a grid
        for (var i = -1; i <= 1; i++) {
            for (var j = -1; j <= 1; j++) {
                modelViewMatrix.setTranslate(i * 2, j * 2, 0);
                gl.uniformMatrix4fv(u_ModelViewMatrix, false, modelViewMatrix.elements);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
            }
        }
    </script>
</body>
</html>
